
\section{Transition Systems and Refinement Mappings}
\label{transition-systems}

In this section,  we establish the  formal theory for using an abstract
non-deterministic program as   a safety specification so  that any
behaviour is safe as long as it is generated by the abstract program.  An implementation
is then defined as  a refinement of  this program.  The basic concepts
are those of {\em transition systems}, {\em traces}, {\em invariants},
{\em  observed  transition   systems},   {\em refinements},   and {\em
  refinement mappings}.  The  theory presented is a minor modification
of the theory developed by Abadi and Lamport~\cite{AL:Mappings}.     
We first introduce   the basic concept of  a
transition system.  Specifications as  well as their refinements
are written as transition systems.

\begin{definition}[Transition System]
A transition system is a triple $(\Sigma,I,N)$, where

\begin{itemize}

  \item $\Sigma$ is a {\em state} space

  \item $I \subseteq \Sigma$ is the set of {\em initial} states.

  \item $N \subseteq \Sigma \times \Sigma$ is the {\em next-state} relation.
        Elements of $N$ are denoted by pairs of the form $(s,t)$, meaning that
        there is a transition from the state $s$ to the state $t$.

\end{itemize}
\end{definition}

\noindent
An {\em execution trace\/}  is an infinite sequence of
states,  where  the first state  satisfies  the initiality predicate and
every pair  of adjacent states is  related  by the  next-state
relation.  A 
sequence $\sigma$  is just an infinite enumeration  of states $\langle s_0,
s_1,  s_2, \ldots \rangle$.     We  let $\sigma_i$ denote  the  $i$'th
element $s_i$  of the  sequence.    The traces of   a transition
system can be defined as follows.

\begin{definition}[Traces]
\label{def-traces}
  The traces of a transition system are defined as follows:

\[
\Theta(\Sigma,I,N) = \{ \sigma \in \Sigma^{\omega} \mid 
                          \sigma_0 \in I \wedge
                          \forall i \ge 0 \cdot N(\sigma_i,\sigma_{i+1}) \}
\] 
\end{definition}

\noindent
We shall need the notion of a  transition system invariant, which is
a state predicate true  in all states reachable  from an initial state
by following the next-state relation.

\begin{definition}[Invariant]
\label{def-invariants}
Given a transition system $S = (\Sigma,I,N)$, then a predicate 
$P : \Sigma \rightarrow {\cal B}$ is an $S$ invariant iff.

\[
\forall \sigma \in \Theta(S) \cdot 
\forall i \ge 0 \cdot P(\sigma_i)
\]

\end{definition}

\noindent
Since we want to compare transition systems, and decide whether one transition
system refines another, we need a notion of {\em observability}.
For that purpose, we extend transition systems with an {\em observation 
function}, which when applied to a state returns an observation in some domain.

\begin{definition}[Observed Transition System]
\label{def-observed-transition-system}  
An        observed  transition      system      is  a     five-tuple
$(\Sigma,\Sigma_o,I,N,\pi)$ where

\begin{itemize}

  \item $(\Sigma,I,N)$ is a transition system

  \item $\Sigma_o$ is a state space, the observed one

  \item $\pi : \Sigma \rightarrow \Sigma_o$ is an {\em observation function}
        that extracts the observed part of a state.

\end{itemize}
\end{definition}

\noindent
Typically (at least in our case) a state  $s \in \Sigma$ consists
of an   observable  part $s_{obs} \in \Sigma_o$  and  an  internal part
$s_{int}$, hence $s = (s_{obs},s_{int})$ and $\pi$ is just the
projection function: $\pi(s_{obs},s_{int}) = s_{obs}$.
We adopt the convention that a projection  function $\pi$ applied to a
trace $\langle s_1,  s_2, \ldots \rangle$ results in  the
projected trace $\langle \pi(s_1), \pi(s_2), \ldots \rangle$.

The central concept in all this is  the notion of refinement: that one
observed transition system  $S_2$ refines  another observed transition
system $S_1$.  By  this we intuitively mean  that every observation we
can make on  $S_2$,  we can  also make on   $S_1$.  Hence,  if  $S_1$
behaves safely so will $S_2$ since every projected  trace of $S_2$ is  a
projected trace  of $S_1$.  
This is formulated in the following definition.

\begin{definition}[Refinement]
\label{def-refinement}
An observed transition system\\ 
  $S_2$ $=$ $(\Sigma_2,\Sigma_o,I_2,N_2,\pi_2)$ 
{\em refines} an observed transition system   
  $S_1$ $=$ $(\Sigma_1,\Sigma_o,I_1,N_1,\pi_1)$ 
iff 
for every trace of $S_2$ there exists a trace of $S_1$ with the same observed states
(note that they have the same observed state space $\Sigma_o$):

\[
  \forall \sigma_2 \in \Theta(S_2) \cdot 
    \exists \sigma_1 \in \Theta(S_1) \cdot
      \pi_1(\sigma_1) = \pi_2(\sigma_2)
\]
\end{definition}

\noindent
We have thus established  what it means for one  observed transition
system to refine another, but we still need  a  practical way of
showing refinement.  Note  that 
refinement is defined in terms of traces which are infinite objects
so that reasoning about them directly is impractical.  We need a way  of
reasoning  about states and pairs of states. A {\em refinement mapping} is
a suitable tool for this purpose.  A 
refinement  mapping from  a  lower  level  transition system $S_2$ to   a
higher-level  one $S_1$ is    a mapping from the state space  $\Sigma_2$ to
the  state space $\Sigma_1$, that when applied statewise, 
maps traces of $S_2$ to traces of $S_1$.  This is formally stated as
follows.

\begin{definition}[Refinement Mapping]
\label{def-refinement-mapping}
A {\em refinement mapping} from an observed transition system
  $S_2 = (\Sigma_2,\Sigma_o,I_2,N_2,\pi_2)$
to an observed transition system
  $S_1 = (\Sigma_1,\Sigma_o,I_1,N_1,\pi_1)$
is a mapping $f : \Sigma_2 \rightarrow \Sigma_1$ such that there exists an
$S_2$ invariant $P$ (representing reachable states in $S_2$),  where:

\begin{enumerate}

 \item $\forall s \in \Sigma_2 \cdot \pi_1(f(s)) = \pi_2(s)$

 \item $\forall s \in \Sigma_2 \cdot I_2(s) \Rightarrow I_1(f(s))$

 \item $\forall s,t \in \Sigma_2 \cdot 
          P(s) \wedge P(t) \wedge N_2(s,t) \Rightarrow N_1(f(s),f(t))$ 
       
\end{enumerate}
\end{definition}

\noindent
Property 1 says that the observation of a state in $S_2$ is the same as that of
its image in $S_1$ obtained by applying the refinement mapping.
%
Property 2 says that an initial state in $S_2$ is mapped to an initial state in $S_1$.
%
Property 3 says that if two {\em reachable} states (satisfying the invariant $P$) 
in $S_2$ are connected via $S_2$'s next-state relation, then their images in $S_1$ 
are correspondingly connected via $S_1$'s next-state relation.

We   can now    state   the  main   theorem   (which  is   stated   in
\cite{AL:Mappings}, and which we have proved in  PVS for our slightly
modified version):

\begin{theorem}[Existence of Refinement Mappings]
\label{theorem-refinement}
If there exists a refinement mapping from an observed transition system $S_2$
to an observed transition system $S_1$, then $S_2$ refines $S_1$. 

\end{theorem}

We shall show how we demonstrate the  existence of refinement mappings
in PVS,  by providing a {\em witness},  that is: defining a particular
one. Defining the refinement mapping  turns out typically to be  easy,
whereas showing that it is indeed a refinement mapping (the properties
in Definition~\ref{def-refinement-mapping}) is  where the  major  effort
goes.  Especially finding and proving the invariant $P$ is the bulk of
the proof.

We   differ from Abadi  and Lamport~\cite{AL:Mappings} in two
ways.  First, we allow general  observation functions, and not
just projection functions that are the identity map on a subset of   the
state space.   Second, in Definition~\ref{def-refinement-mapping} of
refinement mappings,  we  assume that states  $s$  and $t$  satisfy an
implementation     invariant  $P$,   which    is   not   the  case
in~\cite{AL:Mappings}\@.   We have thus weakened the premises of
the refinement rule.  Whereas the introduction of observation functions
is just a nice (but not   strictly   necessary) generalization,
the use of invariants is of real importance for practical proofs.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 







